{"ast":null,"code":"/**\n * Calculate success rate for a set piece based on various factors\n * @param {Object} player - Player object\n * @param {String} setPieceType - Type of set piece (corners or freeKicks)\n * @returns {Number} - Success rate as a percentage\n */\nexport const calculateSuccessRate = (player, setPieceType) => {\n  if (!player || !player.setPieceSuccessRate || !player.setPieceSuccessRate[setPieceType]) {\n    return 0;\n  }\n  return player.setPieceSuccessRate[setPieceType];\n};\n\n/**\n * Find the optimal player for taking a set piece\n * @param {Array} players - Array of player objects\n * @param {String} setPieceType - Type of set piece (corners or freeKicks)\n * @returns {Object} - The optimal player\n */\nexport const getOptimalPlayerForSetPiece = (players, setPieceType) => {\n  if (!players || players.length === 0) {\n    return null;\n  }\n  return players.reduce((bestPlayer, currentPlayer) => {\n    const currentSuccessRate = calculateSuccessRate(currentPlayer, setPieceType);\n    const bestSuccessRate = calculateSuccessRate(bestPlayer, setPieceType);\n    return currentSuccessRate > bestSuccessRate ? currentPlayer : bestPlayer;\n  }, players[0]);\n};\n\n/**\n * Calculate the best type of delivery based on player abilities and position\n * @param {Object} player - Player object\n * @param {String} setPieceType - Type of set piece\n * @param {Object} position - Position data \n * @returns {String} - Recommended delivery type\n */\nexport const calculateOptimalDeliveryType = (player, setPieceType, position) => {\n  if (setPieceType === 'corners') {\n    if (player.crossingAbility > 85) {\n      return 'inswinger';\n    } else {\n      return 'outswinger';\n    }\n  } else if (setPieceType === 'freeKicks') {\n    const distanceFromGoal = position.distanceToGoal;\n    const isWide = position.isWide;\n    if (distanceFromGoal < 25 && !isWide) {\n      return 'direct';\n    } else if (player.crossingAbility > 85) {\n      return 'lofted';\n    } else {\n      return 'driven';\n    }\n  }\n  return 'standard';\n};\n\n/**\n * Find optimal target players based on set piece type and delivery\n * @param {Array} players - Array of player objects\n * @param {String} setPieceType - Type of set piece\n * @param {String} deliveryType - Type of delivery\n * @returns {Array} - Array of optimal target players\n */\nexport const findOptimalTargets = (players, setPieceType, deliveryType) => {\n  if (!players || players.length === 0) {\n    return [];\n  }\n\n  // Sort by height for crosses and aerial threats\n  if (setPieceType === 'corners' || setPieceType === 'freeKicks' && deliveryType !== 'direct') {\n    return players.sort((a, b) => {\n      // Prioritize by height for aerial threats\n      if (a.height !== b.height) {\n        return b.height - a.height;\n      }\n      // Then by goals from set pieces\n      return b.goalsFromSetPieces - a.goalsFromSetPieces;\n    }).slice(0, 3); // Return top 3 targets\n  }\n\n  // For direct free kicks, sort by free kick ability\n  return players.sort((a, b) => {\n    return b.setPieceSuccessRate.freeKicks - a.setPieceSuccessRate.freeKicks;\n  }).slice(0, 1); // Only need the taker\n};","map":{"version":3,"names":["calculateSuccessRate","player","setPieceType","setPieceSuccessRate","getOptimalPlayerForSetPiece","players","length","reduce","bestPlayer","currentPlayer","currentSuccessRate","bestSuccessRate","calculateOptimalDeliveryType","position","crossingAbility","distanceFromGoal","distanceToGoal","isWide","findOptimalTargets","deliveryType","sort","a","b","height","goalsFromSetPieces","slice","freeKicks"],"sources":["C:/Users/Giridharan U/Desktop/tacti-kick/football-set-piece-analyzer/src/utils/analytics.js"],"sourcesContent":["/**\n * Calculate success rate for a set piece based on various factors\n * @param {Object} player - Player object\n * @param {String} setPieceType - Type of set piece (corners or freeKicks)\n * @returns {Number} - Success rate as a percentage\n */\nexport const calculateSuccessRate = (player, setPieceType) => {\n    if (!player || !player.setPieceSuccessRate || !player.setPieceSuccessRate[setPieceType]) {\n        return 0;\n    }\n    return player.setPieceSuccessRate[setPieceType];\n};\n\n/**\n * Find the optimal player for taking a set piece\n * @param {Array} players - Array of player objects\n * @param {String} setPieceType - Type of set piece (corners or freeKicks)\n * @returns {Object} - The optimal player\n */\nexport const getOptimalPlayerForSetPiece = (players, setPieceType) => {\n    if (!players || players.length === 0) {\n        return null;\n    }\n    \n    return players.reduce((bestPlayer, currentPlayer) => {\n        const currentSuccessRate = calculateSuccessRate(currentPlayer, setPieceType);\n        const bestSuccessRate = calculateSuccessRate(bestPlayer, setPieceType);\n        \n        return currentSuccessRate > bestSuccessRate ? currentPlayer : bestPlayer;\n    }, players[0]);\n};\n\n/**\n * Calculate the best type of delivery based on player abilities and position\n * @param {Object} player - Player object\n * @param {String} setPieceType - Type of set piece\n * @param {Object} position - Position data \n * @returns {String} - Recommended delivery type\n */\nexport const calculateOptimalDeliveryType = (player, setPieceType, position) => {\n    if (setPieceType === 'corners') {\n        if (player.crossingAbility > 85) {\n            return 'inswinger';\n        } else {\n            return 'outswinger';\n        }\n    } else if (setPieceType === 'freeKicks') {\n        const distanceFromGoal = position.distanceToGoal;\n        const isWide = position.isWide;\n        \n        if (distanceFromGoal < 25 && !isWide) {\n            return 'direct';\n        } else if (player.crossingAbility > 85) {\n            return 'lofted';\n        } else {\n            return 'driven';\n        }\n    }\n    \n    return 'standard';\n};\n\n/**\n * Find optimal target players based on set piece type and delivery\n * @param {Array} players - Array of player objects\n * @param {String} setPieceType - Type of set piece\n * @param {String} deliveryType - Type of delivery\n * @returns {Array} - Array of optimal target players\n */\nexport const findOptimalTargets = (players, setPieceType, deliveryType) => {\n    if (!players || players.length === 0) {\n        return [];\n    }\n    \n    // Sort by height for crosses and aerial threats\n    if (setPieceType === 'corners' || \n        (setPieceType === 'freeKicks' && deliveryType !== 'direct')) {\n        return players\n            .sort((a, b) => {\n                // Prioritize by height for aerial threats\n                if (a.height !== b.height) {\n                    return b.height - a.height;\n                }\n                // Then by goals from set pieces\n                return b.goalsFromSetPieces - a.goalsFromSetPieces;\n            })\n            .slice(0, 3); // Return top 3 targets\n    }\n    \n    // For direct free kicks, sort by free kick ability\n    return players\n        .sort((a, b) => {\n            return b.setPieceSuccessRate.freeKicks - a.setPieceSuccessRate.freeKicks;\n        })\n        .slice(0, 1); // Only need the taker\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { calculateSuccessRate, getOptimalPlayerForSetPiece } from '../utils/analytics';\nimport { players } from '../data/players';\nimport { setPieces } from '../data/setpieces';\nimport { getPlayersByTeamId, getCornerAnalysis, getFreeKickAnalysis, getTargetPlayers, getPlayerById } from './dataFetcher';\n\n/**\n * Determines the type of set piece based on pitch coordinates\n * @param {Object} coordinates - {x, y} coordinates on the pitch (0-100 for both axes)\n * @returns {String} - 'corner' or 'freeKick'\n */\nexport const determineSetPieceType = coordinates => {\n  const {\n    x,\n    y\n  } = coordinates;\n\n  // Corner detection - near corners of the pitch\n  if ((x <= 5 || x >= 95) && (y <= 5 || y >= 95)) {\n    return 'corner';\n  }\n\n  // Free kick for everything else\n  return 'freeKick';\n};\n\n/**\n * Determines the specific zone of a free kick\n * @param {Object} coordinates - {x, y} coordinates \n * @returns {String} - Zone ID from the free kick zones\n */\nexport const determineFreeKickZone = coordinates => {\n  const {\n    x,\n    y\n  } = coordinates;\n  const freeKickZones = getFreeKickAnalysis().zones;\n\n  // Approximate goal position at x=50, y=100\n  const distanceFromGoal = Math.sqrt(Math.pow(x - 50, 2) + Math.pow(y - 100, 2));\n  const isWide = Math.abs(x - 50) > 15; // More than 15 units from center is considered wide\n\n  if (distanceFromGoal < 25) {\n    // Close to goal - direct range\n    if (!isWide) {\n      return freeKickZones.find(zone => zone.id === 'directRange');\n    } else {\n      return freeKickZones.find(zone => zone.id === 'wideCloseRange');\n    }\n  } else {\n    // Further from goal\n    if (isWide) {\n      return freeKickZones.find(zone => zone.id === 'deepWide');\n    } else {\n      return freeKickZones.find(zone => zone.id === 'deepCentral');\n    }\n  }\n};\n\n/**\n * Determines the specific corner type\n * @param {Object} coordinates - {x, y} coordinates\n * @returns {String} - 'left' or 'right' corner\n */\nexport const determineCornerType = coordinates => {\n  const {\n    x\n  } = coordinates;\n  if (x <= 5) {\n    return 'left';\n  } else {\n    return 'right';\n  }\n};\n\n/**\n * Generates set piece recommendations based on team and pitch position\n * @param {Number} teamId - Team ID\n * @param {Object} coordinates - {x, y} coordinates on the pitch\n * @returns {Object} - Set piece recommendations\n */\nexport const generateRecommendation = (teamId, coordinates) => {\n  const setPieceType = determineSetPieceType(coordinates);\n  const teamPlayers = getPlayersByTeamId(teamId);\n  if (setPieceType === 'corner') {\n    return generateCornerRecommendation(teamId, coordinates, teamPlayers);\n  } else {\n    return generateFreeKickRecommendation(teamId, coordinates, teamPlayers);\n  }\n};\n\n/**\n * Generates corner recommendations\n * @param {Number} teamId - Team ID\n * @param {Object} coordinates - {x, y} coordinates\n * @param {Array} teamPlayers - Players from the selected team\n * @returns {Object} - Corner recommendations\n */\nconst generateCornerRecommendation = (teamId, coordinates, teamPlayers) => {\n  const cornerType = determineCornerType(coordinates);\n  const cornerData = getCornerAnalysis();\n  const targetData = getTargetPlayers().cornerTargets;\n\n  // Find best taker based on crossing ability and set piece success rate\n  const bestTaker = teamPlayers.reduce((best, player) => {\n    if (!best || player.crossingAbility > best.crossingAbility) {\n      return player;\n    }\n    return best;\n  }, null);\n\n  // Find the best delivery type for this taker\n  const bestDeliveryTypes = cornerData.deliveryTypes.filter(delivery => delivery.bestTakers.includes(bestTaker.id));\n\n  // Default to the first delivery type if none found\n  const recommendedDelivery = bestDeliveryTypes.length > 0 ? bestDeliveryTypes[0] : cornerData.deliveryTypes[0];\n\n  // Find best zones for this delivery type\n  const bestZone = cornerData.zones.reduce((best, zone) => {\n    if (!best || zone.successRate[recommendedDelivery.id.toLowerCase()] > best.successRate[recommendedDelivery.id.toLowerCase()]) {\n      return zone;\n    }\n    return best;\n  }, cornerData.zones[0]);\n\n  // Find best targets for this zone\n  const zoneTargets = targetData.find(target => target.zone === bestZone.id);\n  const bestTargets = zoneTargets ? zoneTargets.bestTargets.map(id => getPlayerById(id)).filter(player => teamPlayers.some(tp => tp.id === player.id)) : [];\n  return {\n    type: 'corner',\n    cornerType,\n    taker: bestTaker,\n    deliveryType: recommendedDelivery,\n    targetZone: bestZone,\n    targetPlayers: bestTargets.slice(0, 3) // Top 3 targets\n  };\n};\n\n/**\n * Generates free kick recommendations\n * @param {Number} teamId - Team ID\n * @param {Object} coordinates - {x, y} coordinates\n * @param {Array} teamPlayers - Players from the selected team\n * @returns {Object} - Free kick recommendations\n */\nconst generateFreeKickRecommendation = (teamId, coordinates, teamPlayers) => {\n  const freeKickZone = determineFreeKickZone(coordinates);\n  const freeKickData = getFreeKickAnalysis();\n  const targetData = getTargetPlayers().freeKickTargets;\n\n  // Find if direct shot or cross is better for this zone\n  const isDirect = freeKickZone.successRate.direct > freeKickZone.successRate.crossed;\n\n  // Find the appropriate delivery type\n  let recommendedDelivery;\n  if (isDirect) {\n    recommendedDelivery = freeKickData.deliveryTypes.find(dt => dt.id === 'direct');\n  } else {\n    // For crosses, find the best crosser in the team\n    const bestCrosser = teamPlayers.reduce((best, player) => {\n      if (!best || player.crossingAbility > best.crossingAbility) {\n        return player;\n      }\n      return best;\n    }, null);\n\n    // Find which delivery type the crosser is best at\n    const crossDeliveryTypes = freeKickData.deliveryTypes.filter(dt => dt.id !== 'direct' && dt.bestTakers.includes(bestCrosser.id));\n    recommendedDelivery = crossDeliveryTypes.length > 0 ? crossDeliveryTypes[0] : freeKickData.deliveryTypes.find(dt => dt.id === 'inSwinger');\n  }\n\n  // Find best taker for this delivery type\n  const bestTaker = teamPlayers.reduce((best, player) => {\n    if (recommendedDelivery.bestTakers.includes(player.id)) {\n      if (!best || player.setPieceSuccessRate.freeKicks > best.setPieceSuccessRate.freeKicks) {\n        return player;\n      }\n    }\n    return best;\n  }, teamPlayers[0]);\n\n  // Find best targets for crosses (if not direct)\n  let bestTargets = [];\n  if (!isDirect) {\n    const zoneTargets = targetData.find(target => target.zone === freeKickZone.id);\n    bestTargets = zoneTargets && zoneTargets.bestTargets ? zoneTargets.bestTargets.map(id => getPlayerById(id)).filter(player => teamPlayers.some(tp => tp.id === player.id)) : [];\n  }\n  return {\n    type: 'freeKick',\n    zone: freeKickZone,\n    isDirect,\n    taker: bestTaker,\n    deliveryType: recommendedDelivery,\n    targetPlayers: bestTargets.slice(0, 3) // Top 3 targets\n  };\n};\n\n/**\n * Generates set piece recommendations based on team and set piece type\n * @param {String} team - Team name\n * @param {String} setPieceType - Type of set piece (e.g., 'corner', 'freeKick')\n * @param {Object} position - Position object containing distance to box\n * @returns {Object} - Set piece recommendations\n */\nexport const recommendSetPieceExecution = (team, setPieceType, position) => {\n  const teamSetPieces = setPieces.filter(sp => sp.team === team && sp.type === setPieceType);\n  if (teamSetPieces.length === 0) {\n    return {\n      message: \"No set piece data available for this team and type.\"\n    };\n  }\n  const successRates = teamSetPieces.map(sp => calculateSuccessRate(sp));\n  const bestSuccessRate = Math.max(...successRates);\n  const bestSetPiece = teamSetPieces[successRates.indexOf(bestSuccessRate)];\n  const optimalPlayer = getOptimalPlayerForSetPiece(players, bestSetPiece);\n  const recommendations = {\n    player: optimalPlayer.name,\n    trajectory: bestSetPiece.trajectory,\n    target: bestSetPiece.target,\n    directOrIndirect: position.distanceToBox < 20 ? 'Direct' : 'Indirect'\n  };\n  return recommendations;\n};","map":{"version":3,"names":["calculateSuccessRate","getOptimalPlayerForSetPiece","players","setPieces","getPlayersByTeamId","getCornerAnalysis","getFreeKickAnalysis","getTargetPlayers","getPlayerById","determineSetPieceType","coordinates","x","y","determineFreeKickZone","freeKickZones","zones","distanceFromGoal","Math","sqrt","pow","isWide","abs","find","zone","id","determineCornerType","generateRecommendation","teamId","setPieceType","teamPlayers","generateCornerRecommendation","generateFreeKickRecommendation","cornerType","cornerData","targetData","cornerTargets","bestTaker","reduce","best","player","crossingAbility","bestDeliveryTypes","deliveryTypes","filter","delivery","bestTakers","includes","recommendedDelivery","length","bestZone","successRate","toLowerCase","zoneTargets","target","bestTargets","map","some","tp","type","taker","deliveryType","targetZone","targetPlayers","slice","freeKickZone","freeKickData","freeKickTargets","isDirect","direct","crossed","dt","bestCrosser","crossDeliveryTypes","setPieceSuccessRate","freeKicks","recommendSetPieceExecution","team","position","teamSetPieces","sp","message","successRates","bestSuccessRate","max","bestSetPiece","indexOf","optimalPlayer","recommendations","name","trajectory","directOrIndirect","distanceToBox"],"sources":["C:/Users/Giridharan U/Desktop/tacti-kick/football-set-piece-analyzer/src/services/recommendationEngine.js"],"sourcesContent":["import { calculateSuccessRate, getOptimalPlayerForSetPiece } from '../utils/analytics';\nimport { players } from '../data/players';\nimport { setPieces } from '../data/setpieces';\nimport {\n    getPlayersByTeamId,\n    getCornerAnalysis,\n    getFreeKickAnalysis,\n    getTargetPlayers,\n    getPlayerById\n} from './dataFetcher';\n\n/**\n * Determines the type of set piece based on pitch coordinates\n * @param {Object} coordinates - {x, y} coordinates on the pitch (0-100 for both axes)\n * @returns {String} - 'corner' or 'freeKick'\n */\nexport const determineSetPieceType = (coordinates) => {\n    const { x, y } = coordinates;\n    \n    // Corner detection - near corners of the pitch\n    if ((x <= 5 || x >= 95) && (y <= 5 || y >= 95)) {\n        return 'corner';\n    }\n    \n    // Free kick for everything else\n    return 'freeKick';\n};\n\n/**\n * Determines the specific zone of a free kick\n * @param {Object} coordinates - {x, y} coordinates \n * @returns {String} - Zone ID from the free kick zones\n */\nexport const determineFreeKickZone = (coordinates) => {\n    const { x, y } = coordinates;\n    const freeKickZones = getFreeKickAnalysis().zones;\n    \n    // Approximate goal position at x=50, y=100\n    const distanceFromGoal = Math.sqrt(Math.pow(x - 50, 2) + Math.pow(y - 100, 2));\n    const isWide = Math.abs(x - 50) > 15; // More than 15 units from center is considered wide\n    \n    if (distanceFromGoal < 25) {\n        // Close to goal - direct range\n        if (!isWide) {\n            return freeKickZones.find(zone => zone.id === 'directRange');\n        } else {\n            return freeKickZones.find(zone => zone.id === 'wideCloseRange');\n        }\n    } else {\n        // Further from goal\n        if (isWide) {\n            return freeKickZones.find(zone => zone.id === 'deepWide');\n        } else {\n            return freeKickZones.find(zone => zone.id === 'deepCentral');\n        }\n    }\n};\n\n/**\n * Determines the specific corner type\n * @param {Object} coordinates - {x, y} coordinates\n * @returns {String} - 'left' or 'right' corner\n */\nexport const determineCornerType = (coordinates) => {\n    const { x } = coordinates;\n    \n    if (x <= 5) {\n        return 'left';\n    } else {\n        return 'right';\n    }\n};\n\n/**\n * Generates set piece recommendations based on team and pitch position\n * @param {Number} teamId - Team ID\n * @param {Object} coordinates - {x, y} coordinates on the pitch\n * @returns {Object} - Set piece recommendations\n */\nexport const generateRecommendation = (teamId, coordinates) => {\n    const setPieceType = determineSetPieceType(coordinates);\n    const teamPlayers = getPlayersByTeamId(teamId);\n    \n    if (setPieceType === 'corner') {\n        return generateCornerRecommendation(teamId, coordinates, teamPlayers);\n    } else {\n        return generateFreeKickRecommendation(teamId, coordinates, teamPlayers);\n    }\n};\n\n/**\n * Generates corner recommendations\n * @param {Number} teamId - Team ID\n * @param {Object} coordinates - {x, y} coordinates\n * @param {Array} teamPlayers - Players from the selected team\n * @returns {Object} - Corner recommendations\n */\nconst generateCornerRecommendation = (teamId, coordinates, teamPlayers) => {\n    const cornerType = determineCornerType(coordinates);\n    const cornerData = getCornerAnalysis();\n    const targetData = getTargetPlayers().cornerTargets;\n    \n    // Find best taker based on crossing ability and set piece success rate\n    const bestTaker = teamPlayers.reduce((best, player) => {\n        if (!best || player.crossingAbility > best.crossingAbility) {\n            return player;\n        }\n        return best;\n    }, null);\n    \n    // Find the best delivery type for this taker\n    const bestDeliveryTypes = cornerData.deliveryTypes.filter(\n        delivery => delivery.bestTakers.includes(bestTaker.id)\n    );\n    \n    // Default to the first delivery type if none found\n    const recommendedDelivery = bestDeliveryTypes.length > 0 \n        ? bestDeliveryTypes[0] \n        : cornerData.deliveryTypes[0];\n    \n    // Find best zones for this delivery type\n    const bestZone = cornerData.zones.reduce((best, zone) => {\n        if (!best || zone.successRate[recommendedDelivery.id.toLowerCase()] > \n            best.successRate[recommendedDelivery.id.toLowerCase()]) {\n            return zone;\n        }\n        return best;\n    }, cornerData.zones[0]);\n    \n    // Find best targets for this zone\n    const zoneTargets = targetData.find(target => target.zone === bestZone.id);\n    const bestTargets = zoneTargets \n        ? zoneTargets.bestTargets.map(id => getPlayerById(id)).filter(player => \n            teamPlayers.some(tp => tp.id === player.id))\n        : [];\n    \n    return {\n        type: 'corner',\n        cornerType,\n        taker: bestTaker,\n        deliveryType: recommendedDelivery,\n        targetZone: bestZone,\n        targetPlayers: bestTargets.slice(0, 3) // Top 3 targets\n    };\n};\n\n/**\n * Generates free kick recommendations\n * @param {Number} teamId - Team ID\n * @param {Object} coordinates - {x, y} coordinates\n * @param {Array} teamPlayers - Players from the selected team\n * @returns {Object} - Free kick recommendations\n */\nconst generateFreeKickRecommendation = (teamId, coordinates, teamPlayers) => {\n    const freeKickZone = determineFreeKickZone(coordinates);\n    const freeKickData = getFreeKickAnalysis();\n    const targetData = getTargetPlayers().freeKickTargets;\n    \n    // Find if direct shot or cross is better for this zone\n    const isDirect = freeKickZone.successRate.direct > freeKickZone.successRate.crossed;\n    \n    // Find the appropriate delivery type\n    let recommendedDelivery;\n    if (isDirect) {\n        recommendedDelivery = freeKickData.deliveryTypes.find(dt => dt.id === 'direct');\n    } else {\n        // For crosses, find the best crosser in the team\n        const bestCrosser = teamPlayers.reduce((best, player) => {\n            if (!best || player.crossingAbility > best.crossingAbility) {\n                return player;\n            }\n            return best;\n        }, null);\n        \n        // Find which delivery type the crosser is best at\n        const crossDeliveryTypes = freeKickData.deliveryTypes.filter(dt => \n            dt.id !== 'direct' && dt.bestTakers.includes(bestCrosser.id)\n        );\n        \n        recommendedDelivery = crossDeliveryTypes.length > 0 \n            ? crossDeliveryTypes[0] \n            : freeKickData.deliveryTypes.find(dt => dt.id === 'inSwinger');\n    }\n    \n    // Find best taker for this delivery type\n    const bestTaker = teamPlayers.reduce((best, player) => {\n        if (recommendedDelivery.bestTakers.includes(player.id)) {\n            if (!best || player.setPieceSuccessRate.freeKicks > best.setPieceSuccessRate.freeKicks) {\n                return player;\n            }\n        }\n        return best;\n    }, teamPlayers[0]);\n    \n    // Find best targets for crosses (if not direct)\n    let bestTargets = [];\n    if (!isDirect) {\n        const zoneTargets = targetData.find(target => target.zone === freeKickZone.id);\n        bestTargets = zoneTargets && zoneTargets.bestTargets \n            ? zoneTargets.bestTargets.map(id => getPlayerById(id)).filter(player => \n                teamPlayers.some(tp => tp.id === player.id))\n            : [];\n    }\n    \n    return {\n        type: 'freeKick',\n        zone: freeKickZone,\n        isDirect,\n        taker: bestTaker,\n        deliveryType: recommendedDelivery,\n        targetPlayers: bestTargets.slice(0, 3) // Top 3 targets\n    };\n};\n\n/**\n * Generates set piece recommendations based on team and set piece type\n * @param {String} team - Team name\n * @param {String} setPieceType - Type of set piece (e.g., 'corner', 'freeKick')\n * @param {Object} position - Position object containing distance to box\n * @returns {Object} - Set piece recommendations\n */\nexport const recommendSetPieceExecution = (team, setPieceType, position) => {\n    const teamSetPieces = setPieces.filter(sp => sp.team === team && sp.type === setPieceType);\n    \n    if (teamSetPieces.length === 0) {\n        return { message: \"No set piece data available for this team and type.\" };\n    }\n\n    const successRates = teamSetPieces.map(sp => calculateSuccessRate(sp));\n    const bestSuccessRate = Math.max(...successRates);\n    const bestSetPiece = teamSetPieces[successRates.indexOf(bestSuccessRate)];\n\n    const optimalPlayer = getOptimalPlayerForSetPiece(players, bestSetPiece);\n    \n    const recommendations = {\n        player: optimalPlayer.name,\n        trajectory: bestSetPiece.trajectory,\n        target: bestSetPiece.target,\n        directOrIndirect: position.distanceToBox < 20 ? 'Direct' : 'Indirect'\n    };\n\n    return recommendations;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}